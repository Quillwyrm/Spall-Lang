SPALL ‚Äî Sequential Pixel Art Layer Language
A declarative instruction flow for procedural pixel tiles, inspired by minimal stack languages (PostScript, Forth), BASIC, and ASM.

Buffers: TMP & MAIN
TMP = the current OP in isolation (CIRC 4 4 4; TMP = just the drawn circ), TMP is a virtual scratch buffer; never survives unless explicitly saved ( CIRC 4 4 4 : circ1 )

MAIN = the current CUMULATIVE buffer, that TMP's merge into (the TILE at each stage, with all OP's applied)





üß† Merge Rules (Finalized)
Situation	Result
TMP is used (e.g. ERASE MASK)	TMP is consumed, no merge
TMP is saved (: foo)	TMP is captured, no merge
TMP is left unbound	Next op triggers implicit merge
TMP is last op in script	Auto-merge to MAIN unless named


üîÅ Full project Stack-flow
Layer	         Role
Your DSL	 Concise 1-bit graphics IR
Transpiler	 Converts IR tokens into Lua function calls
Lua API	         Executes the buffer mutations
Matrix<int>	 The backing data structure for tiles


üßæ Canonical Prefixes
Prefix	Meaning
>	Global directive / config block
:	Reusable block definition
#	Output tile definition

























üéõÔ∏è Spall REPL Editor Flow (Love2D + Lua)
1. Text Input
User types Spall code into your IMGUI multiline textbox.

2. Transpile
On "Run" button:

Save the code to temp.spall

Transpile it to out.lua using your Spall compiler

3. Auto-wrap Return
At the end of out.lua, emit:

lua
Copy
Edit
return tiles
Where tiles is a Dict<String, Frame> (e.g. { hello_dot = MAIN })

4. Load & Execute
In your editor:

lua
Copy
Edit
local tiles = loadfile("out.lua")()
local tile = tiles["hello_dot"]
drawFrame(tile)
5. Display Output
Render the tile with your drawFrame() or drawMatrix() function in Love2D

Optionally allow selecting between multiple tile outputs (# name blocks)

‚úÖ Benefits
Simple: no runtime VM, no eval hell

Pure: the Lua file just returns data

Composable: supports multiple tiles

Fast: transpile, load, draw ‚Äî done