--= Global Directives & Config
> palette         -- Indexed palette declaration  
> size            -- Global tile size (optional; can be set per tile with `# tile 8 8`)  
> vars            -- Global static vars  
> rand            -- Global random vars  
> loops           -- Global iterated vars  
> frames          -- Global frame vars  
> import          -- `.spd` imports; each file bound to a name to use its shape  
> meta            -- Metadata: author, name, version, tags (for SpallEd)

--= User Defs
: blockName         -- Bind a set of operations to a name, capturing the final buffer  
- polyName          -- Define a shape path (polydef); list of verts, straight or bezier 
# tile_name         -- Define a tile to output
<expr/ops> : name   -- Name an operation or expression result for reuse  

--= Draw Ops  (all [c] default to C1 if omitted)
-- Shape Primitives  
blit [c] x y                            -- Place single pixel  
line [c] x1 y1 x2 y2                    -- Draw line  
rect [c] x y w h <drawmod>              -- Draw filled rectangle  
circ [c] x y r <drawmod>                -- Draw filled circle  
oval [c] x y w h <drawmod>              -- Draw filled oval (ellipse) inside wÃ—h box 
arc  [c] x y r a1 a2 [w] <drawmod>      -- Arc stroke from a1â†’a2; Mod: stroke width & placement  
pie  [c] x y r a1 a2 <drawmod>          -- Filled wedge; optional stroke   

name [c] x y                            -- Draw user-bound buffer literal at (x, y), optional recolor
grid [c] x y cols rows w h <gridmod>    -- Draw grid lines;  -- w/h = cell size; origin = top-left  
-                                       -- Mods: - <stagger MODE px> (Modes: ROW | COL)  
-								                                 - <wave MODE > ***WIP***  

flood c x y                             -- Flood-fill BASE buffer from (x,y) with color `c` (pure op, emits TEMP)

--= Draw Mods (inline with draw ops, never emit buffers)
<stroke c w MODE>         -- Add stroke to shape; Modes: OUT | MID | IN  
<shadow c d a>            -- Add shadow; `d` = depth, `a` = angle  

--= Utility Draw Ops
mySprite [c] x y                          -- Draw a bound buffer (block or local)  



--= Transform Ops
trace buff c w MODE         -- Outline a buffer with stroke ***WIP***   
spin buff d                 -- Rotate buffer by degrees 		***WIP***   
shift buff x y [fill]       -- Cut-paste style offset 			***WIP***   
flip buff a                 -- Flip across axis (x or y) 		***WIP***  
mirror MODE                 -- TBD 													***WIP***   

fan buff cx cy sx sy n <fanmod>         -- Radial layout of shape buffer around center  
-                                       -- Modes: BACKSPIN | NOSPIN (n < 0 = CCW)  
-                                       -- Mod: <increment px> â€” radial distance increase per step  

scatter <noisemod>??                             -- Seeded distribution of shapes ***WIP*** 

--= Boolean Ops
merge src dst [MODE]       -- Merge two buffers; Modes: UNION | SUBTRACT | INTERSECT | EXCLUDE  
erase buff                 -- Erase shape from BASE buffer  
invert [buff]              -- Invert buffer or BASE (0 â†”ï¸Ž 1+)  
recolor buff clrA clrB ... -- Remap color indices in buffer (Aâ†’B, Aâ†’B...)

-- Buffer Operators (expression sugar)
a + b     â†’ merge a b UNION  
a - b     â†’ merge a b SUBTRACT  
a * b     â†’ merge a b INTERSECT  
a ^ b     â†’ merge a b EXCLUDE  

--= Utility Ops
last                      -- Use last unnamed buffer in place of shape  

--= Experimental / ***WIP*** 
warp**                    -- ??? (not ruled out) 										***WIP***   
future pattern ops        -- e.g. stripes, checker, dither 					***WIP***   
wrap                      -- Maybe a draw-mode or shape wrap-around ***WIP***  
noise MODE buff density   -- Noise-based buffer patterning 				  ***WIP*** 

--= Syntax Sugar
Whitespace separates all tokens; spacing is flexible but must be clear.
comma `,`                  -- Comma acts as optional whitespace anywhere; purely cosmetic  
Semicolon `;`              -- Semicolon = inline newline; sequences ops in a single line (like Lua)  
-                          -- Example: `circ red 4 4 3 ; last - mask ; last * shape`




SPALL PIXEL DATA - .spd
Raw output format of Spall (actualy just a .lua with tables)
```
return { -- faces.spd
--1-------------------------
  smile = { 
    w = 4; h = 4,
    pixels = {
      {1,2,2,1},
      {2,2,2,2},
      {1,2,2,1},
      {2,1,1,2},},
    x = nil; y = nil,}
--2-------------------------
  frown = { 
    w = 4; h = 4,
    pixels = {
      {1,2,2,1},
      {2,2,2,2},
      {2,1,1,2},
      {1,2,2,1},},
    x = nil; y = nil,}
---------------------------
} -- Spall Pixel Data

```


MVP IMPL:

> palette
> size
# tile

: name

blit
line
rect
circ

stroke
shadow

merge -- Union, Subtract, Intersect, Exclude + Meta 'MODE' Dispatcher
erase








-------------

âœ… Block Resolution Strategy Summary

Goal:
Allow Spall blocks (: name) to reference earlier blocks, without runtime lookups or multipass logic.

ðŸ§  Model
Each : block is evaluated immediately, just like a tile

Instead of committing to _context.tiles, it commits to _context.user[name]

After evaluation, the buffer is promoted to a global:
âœ… Benefits
âœ… Single-pass evaluation

âœ… No runtime indirection

âœ… Blocks become global reusable shapes

âœ… DSL remains composable, predictable, and tight

This is a minimal linker pass for reusable shapes â€” clear, static, and declarative.






last
